---
title: Add Message History
description: Learn how to protect your applications from being overwhelmed with data.
order: 40
---


= Add Message History

The application is now able to post and receive messages, but if you navigate away from a channel and back, you lose all the previous messages. The backend is already storing all the messages and your task is now to make them show up in the user interface when you open the channel view. However, there are a few things to keep in mind:

- Every message is rendered in the DOM. Over time, the number of messages will grow which means you cannot show the complete message history without slowing down the application and consuming a lot of memory.
- You may be receiving messages while fetching the message history. You do not want to miss any of them.
- On the rare occation, you may receive the same message as a part of the message history and as a part of the live stream. You only want a message to show up once in the user interface.

It is good practice to always ensure there is an upper limit on all backend queries. Unless you know for sure that a query will return exactly zero or one item, assume it will return enough items to bring your application down. In this tutorial, we are going to use a ridiculously low limit of only 20 messages in order to make it easier to demonstrate how the limit works.


== Container for Received Messages

You are now going to create a new data type that will hold all the received messages. This data type has the following capabilities:

- The list is always sorted using a [interfacename]`Comparator`.
- The list has a fixed size limit. If the list is full when you add a new item, the first item is automatically removed.
- The list does not allow any duplicates. Duplicates are determined by comparing items using their [methodname]`equals()` method.

Since a Flow user interface is written in 100% Java, you have all the features of the JVM at your disposal. Create a class named [classname]`LimitedSortedAppendOnlyList` inside the [packagename]`com.example.application.util` package, like this:

.`LimitedSortedAppendOnlyList.java`
[source,java]
----
package com.example.application.util;

import java.util.Collection;
import java.util.Comparator;
import java.util.Optional;
import java.util.TreeSet;
import java.util.stream.Stream;

public class LimitedSortedAppendOnlyList<T> {

    private final int limit;
    private final TreeSet<T> items; // <1>

    public LimitedSortedAppendOnlyList(int limit, Comparator<T> comparator) {
        this.limit = limit;
        this.items = new TreeSet<>(comparator); // <2>
    }

    public void add(T item) {
        items.add(item);
        if (items.size() > limit) {
            items.pollFirst(); // <3>
        }
    }

    public void addAll(Collection<T> items) {
        items.forEach(this::add);
    }

    public Stream<T> stream() {
        return items.stream();
    }

    public Optional<T> getLast() {
        if (items.isEmpty()) {
            return Optional.empty();
        }
        return Optional.of(items.getLast());
    }
}
----
<1> [classname]`TreeSet` is a built-in Java [interfacename]`Set` that is always sorted and makes sure there are no duplicates.
<2> [classname]`TreeSet` uses a [interfacename]`Comparator` to sort its items.
<3> [methodname]`pollFirst` is a built-in method for removing the first item in a [classname]`TreeSet`.


== Change the Channel View for New Container

When you implemented the first version of [classname]`ChannelView`, you used an [classname]`ArrayList` as a container of received messages. You are now going to replace this with the newly created [classname]`LimitedSortedAppendOnlyList`.

Open [classname]`ChannelView` and change the field definition of `receivedMessages` like this:

[source,java]
----
private static final int HISTORY_SIZE = 20; // <1>
private final LimitedSortedAppendOnlyList<Message> receivedMessages;
----
<1> We are only going to show the past 20 messages. This makes it easy to manually test that the feature is working properly.

Next, change the constructor like this:

[source,java]
----
public ChannelView(ChatService chatService) {
    this.chatService = chatService;
    receivedMessages = new LimitedSortedAppendOnlyList<>(
            HISTORY_SIZE, // <1>
            Comparator.comparing(Message::sequenceNumber) // <2>
    );

    setSizeFull();

    messageList = new MessageList();
    messageList.setSizeFull();
    add(messageList);

    var messageInput = new MessageInput(event -> sendMessage(event.getValue()));
    messageInput.setWidthFull();
    add(messageInput);
}
----
<1> The list will only contain 20 messages.
<2> Messages will be sorted by their sequence number, which is the number in which they were received by the server.

The `ChannelView` should now compile, as the methods [methodname]`addAll` and [methodname]`stream` are present in both [classname]`ArrayList` and [classname]`LimitedSortedAppendOnlyList`.


== Retrieve Message History

Now with all the plumbing in place, all that remains is to fetch the message history from [classname]`ChatService`. There is a method called [methodname]`messageHistory` that takes the following parameters:

1. The ID of the channel.
2. The number of messages to retrieve.
3. The ID of the latest message that the client has received, if any.

The method will return at most the given number of messages that have been posted to the given channel after the given latest message.

Change the [methodname]`subscribe` method of [classname]`ChannelView` like this:

[source,java]
----
private Disposable subscribe() {
    var subscription = chatService
            .liveMessages(channelId)
            .subscribe(this::receiveMessages);
    var lastSeenMessageId = receivedMessages.getLast() // <1>
        .map(Message::messageId).orElse(null); // <2>
    receiveMessages(chatService.messageHistory(
        channelId, // <3>
        HISTORY_SIZE, // <4>
        lastSeenMessageId
    ));
    return subscription;
}
----
<1> The latest message that the client has received is the last message in the `receivedMessages` list.
<2> If the list is empty, you should pass `null` as the latest message.
<3> The channel ID is already available in a private field.
<4> Retrieve a maximum of 20 messages.

Please note, that you are fetching the history after you have subscribed to the live message feed. Because the list of received messages is sorted by sequence number, it does not matter whether you add the messages to the list in the wrong order - they will still show up correctly.

But what about thread safety? What happens if a message comes in through the live stream in one thread while the history is being retrieved in another thread? This is a valid concern, but fortunately you have already addressed it. Have a look at the [methodname]`receivedMessages` method again.

You will see that all interactions with both the user interface and the `receivedMessages` list is happening inside a call to [methodname]`UI.access`. This acts as a thread synchronization mechanism, as Vaadin will make sure that only one thread at a time can access the same [classname]`UI` instance.


== Try It!

You are now ready to try out the new history feature.

1. Start the application by running `./mvnw spring-boot:run`
2. Open your browser at http://localhost:8080/ and pick a channel.
3. Open another browser window (window 2) and go to the same channel.
4. Write some messages in window 1. They should show up in both windows.
5. Go back to the lobby in window 2.
6. Write some more messages in window 1.
7. Go the channel again in window 2.
8. All the previous messages should show up, including the messages you wrote in step 6.
9. Keep writing messages until you have 20 messages in the view. As you keep writing messages, you should see the oldest one automatically disappear.


++++
<style>
[class^=PageHeader-module--descriptionContainer] {display: none;}
</style>
++++
