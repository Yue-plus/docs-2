---
title: Routing
description: How to implement routing in Hilla React applications.
order: 60
---

= Routing

Hilla React applications are using a file-system based router, which is built on top of https://reactrouter.com/en/main[React Router], a popular routing library for React applications. This documentation can guide you through the basics of using routing in your application.

The file-based router is using the `.tsx` files in the `frontend/views/` directory and its subdirectories as routes.


== Adding Routes

To add a new route to an application, create a new component that should be displayed when the route is active. For example, create a file called [filename]`example.tsx` in the `views` directory with the following content:

[source,tsx]
----
export default function ExampleView() {
  return <div>My first view</div>;
}
----

Now, after saving the file, you should be able to navigate to `http://localhost:8080/example` and see the new component rendered in the browser.

To add a navigation link that points to your new route, use the `<NavLink>` component from `react-router-dom`:

[source,tsx]
----
import { NavLink } from 'react-router-dom';

<NavLink to="/my-view">My View</NavLink>
----

This creates a clickable link in your application that navigates to the specified route.


=== Filename Conventions

Hilla file-system router supports the following file naming conventions for the `.tsx` files in `views` and any nested subdirectories:

`_` at the start — ignore the file::
  The file-system router ignores any files named starting with the underscore character, for example, `_utils.tsx`.
`$index.tsx` — directory index view::
  Files named `$index.tsx` are mapped to the index of the directory. For example, the `views/$index.tsx` file will be mapped to the root URL of the application (`/`).
`$layout.tsx` — directory layout::
  Files named `$layout.tsx` define the layout (view wrapping component) for the other views defined in the same directory or its subdirectories. The layouts are further described in the <<Adding Layout Routes>> section.
`{parameterName}.tsx` — parameter mapping::
  The file name part between the braces is mapped to a route parameter, as described in <<Adding Routes with Parameters>> below.

== Adding Routes with Parameters

Sometimes, you may need to create routes that accept dynamic parameters, such as product IDs or names. This can be done by using the `{parameterName}` filename convention. For example, create the file named `{productId}.tsx` in the `frontend/views/products/` directory with the following content:

[source,tsx]
----
import { useParams } from 'react-router-dom';

export default function ProductView() {
  const { productId } = useParams();

  // Fetch product details for the given ID
  const [ product, setProduct ] = useState<Product>();

  useEffect(() => {
    ProductEndpoint.getProduct(productId).then(setProduct);
  }, [productId]);
}
----

This creates the route with the path `/products/{productId}`, where `{productId}` acts as a placeholder for the actual product ID. To access the route parameter in the view, use the `useParams` hook from `react-router-dom` in your component, as shown in the example above. The view component fetches product data for the product ID in the route.

To link to this route with a specific `productId`, you can use the `to` property of `NavLink` like this:

[source,tsx]
----
<NavLink to="/products/123">Show product details</NavLink>
----


== Adding Layout Routes

Layouts are special view components that wrap around other views. It is common for applications to have at least one layout: the main layout that renders the toolbar, the main manu, and similar functionality.

For adding a layout, create a view file named `$layout.tsx` in the views directory, and render the `<Outlet/>` in the component. You can also use the <<../../../components/app-layout,`App Layout`>> component to add common application layout parts.

The following example defines the main layout with the drawer and the main menu:

[source,tsx]
----
import { AppLayout } from '@vaadin/react-components/AppLayout.js';
import { DrawerToggle } from '@vaadin/react-components/DrawerToggle.js';
import Placeholder from 'Frontend/components/placeholder/Placeholder.js';
import { Suspense, useEffect } from 'react';
import { NavLink, Outlet } from 'react-router-dom';

export default function MainLayout() {

  return (
    <AppLayout primarySection="drawer">
      <div slot="drawer" className="flex flex-col justify-between h-full p-m">
        <header className="flex flex-col gap-m">
          <h1 className="text-l m-0">My application</h1>
          <nav>
            <NavLink to="/example">Example</NavLink>
          </nav>
        </header>
      </div>

      <DrawerToggle slot="navbar" aria-label="Menu toggle"></DrawerToggle>

      <Suspense fallback={<Placeholder />}>
        <Outlet />
      </Suspense>
    </AppLayout>
  );
}
----


== Creating Menu From Routes

The structure of application routes is naturally closely related with navigation menus. The main menu is often directly lists the same items as the routes define, thus it could be created from the routes.

Hilla file-based router offers the `createMenuItems()` utility function to simplify populating the menu using routes data.

The following example demonstrates creating the main menu `createMenuItems()`:

[source,tsx]
----
import { createMenuItems } from '@vaadin/hilla-file-router/runtime.js';
import { NavLink } from 'react-router-dom';

const navLinkClasses = ({ isActive }: any) => {
  return `block rounded-m p-s ${isActive ? 'bg-primary-10 text-primary' : 'text-body'}`;
};

export default function MainMenu() {
  return (
    {createMenuItems().map(({ to, icon, title }) => (
      <NavLink className={navLinkClasses} to={to} key={to}>
        {title}
      </NavLink>
    ))}
  );
}
----


== Customizing Route Configuration

In some cases, you may want to customize the configuration of a route on top of what is inferred from the file. By customizing a route you can, for example, set a page title, a menu link title and icon, or override the route path.

To customize the route to a route, in your view `.tsx` file, export an object named `config` of `ViewConfig` type:

[source,tsx]
.`frontend/views/about.tsx`
----
import { ViewConfig } from "@vaadin/hilla-file-router/types.js";

export default fuction AboutView() {
  return (
    /* ... */
  );
}

export const config: ViewConfig = {
  title: "About Us",
};
----

In this example, a page title is added to the example route.

To access this metadata from within a component, you can use the `useMatches` hook from `react-router-dom`. In the following example, the page title is used to display it in the header of the main layout:

[source,tsx]
----
import { useMatches } from "react-router-dom";

export default function MainLayout() {
  const matches = useMatches();
  const currentHandle = matches[matches.length - 1]?.handle as any;
  const pageTitle = currentHandle?.title ?? 'My App';

  return (
    <AppLayout primarySection="drawer">
      <header slot="drawer">
        <h1 className="text-l m-0">{pageTitle}</h1>
        ...
      </header>
      ...
    </AppLayout>
  );
}
----

Now, when the `/about` route is active, the title `About us` is displayed in the header.

.Helper hook
[NOTE]
====
Hilla starter applications provide a helper hook that simplifies accessing route metadata:

[source,ts]
----
import { useRouteMetadata } from "Frontend/util/routing";

const metadata = useRouteMetadata();
const title = metadata.title ?? "My App";
----
====


== Programmatic Navigation

In some cases, you may need to navigate programmatically between routes. For example, this may be needed in response to user interactions or application logic. For this you can use the `useNavigate` hook from `react-router-dom`. It provides a function that allows you to navigate to a specific route when called. Additionally, it offers options to control the navigation behavior, such as pushing to the history stack or replacing the current entry.

For example, after saving a product, you might want to navigate back to the product list:

[source,tsx]
----
import { useNavigate } from 'react-router-dom';

function ProductDetailView() {
  const navigate = useNavigate();

  const handleSave = async () => {
    await ProductEndpoint.save(product);
    navigate('/products');
  };

  return (
    <div>
      ...
      <button onClick={handleSave}>Save</button>
    </div>
  );
}
----

By default, this pushes a new entry to the browser's navigation history. If you want to replace the current entry instead, you can pass `{ replace: true }` as the second argument like so:

[source,tsx]
----
navigate('/products', { replace: true });
----


== Adding an Error Page

Adding a custom error page to an application is essential for handling situations in which no other route matches the requested URL. This allows you to provide helpful feedback to the user, for example, by communicating the problem or providing links to other pages.

To add an error page (e.g., for 404 not found), create a new route view file for your error page (e.g., `error.tsx`), set the route config to use a wildcard route, and exclude the route from the menu:

[source,tsx]
.`frontend/views/error.tsx`
----
export default function ErrorView() {
  return <div>Page not found</div>;
}

export const config: ViewConfig = {
  route: '*',
  menu: {
    exclude: true,
  },
};
----

This route matches any unknown routes and display the error page.

Customize the `ErrorView` component to provide helpful information to the user.

Now, your application is equipped with an error page that'll be shown when no other route matches a requested URL.


== Further Information

For more information about using React Router, refer to the official documentation:

- https://reactrouter.com/en/main[Homepage]
- https://reactrouter.com/en/main/start/tutorial[Tutorials]
- https://reactrouter.com/en/main/start/examples[Examples]
